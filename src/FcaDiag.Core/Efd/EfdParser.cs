using System.Text;

namespace FcaDiag.Core.Efd;

/// <summary>
/// Parser for CDA6 EFD (EPROM Flash Data) files
/// </summary>
public static class EfdParser
{
    private static readonly byte[] EfdMagic = [0x1A, 0x45, 0xDF, 0xA3];

    /// <summary>
    /// Parses an EFD file from the specified path
    /// </summary>
    public static EfdFile Parse(string filePath)
    {
        if (!File.Exists(filePath))
            throw new FileNotFoundException("EFD file not found", filePath);

        var data = File.ReadAllBytes(filePath);
        var efd = Parse(data);
        efd.FilePath = filePath;
        efd.FileSize = data.Length;
        efd.PartNumber = Path.GetFileNameWithoutExtension(filePath);

        return efd;
    }

    /// <summary>
    /// Parses EFD data from a byte array
    /// </summary>
    public static EfdFile Parse(byte[] data)
    {
        if (data.Length < 256)
            throw new InvalidDataException("File is too small to be a valid EFD file");

        // Verify magic bytes
        if (!data.Take(4).SequenceEqual(EfdMagic))
            throw new InvalidDataException("Invalid EFD file: magic bytes not found");

        var efd = new EfdFile();

        // Parse metadata section (starts around offset 0x180)
        ParseMetadata(data, efd);

        // Parse footer section (last ~256 bytes)
        ParseFooter(data, efd);

        // Extract data blocks
        ExtractDataBlocks(data, efd);

        return efd;
    }

    private static void ParseMetadata(byte[] data, EfdFile efd)
    {
        // Look for metadata section - typically starts with "MY = "
        var metadataStart = FindPattern(data, "MY = "u8.ToArray());
        if (metadataStart < 0)
            return;

        // Read until we hit non-printable characters or end of metadata
        var metadataEnd = metadataStart;
        while (metadataEnd < data.Length - 1)
        {
            // Look for end markers (typically binary data or specific patterns)
            if (data[metadataEnd] == 0x01 && data[metadataEnd + 1] == 0x00)
                break;
            if (data[metadataEnd] < 0x0A || (data[metadataEnd] > 0x0D && data[metadataEnd] < 0x20))
            {
                // Check if this is "CO" or "UP" marker with control bytes
                if (metadataEnd + 3 < data.Length &&
                    ((data[metadataEnd + 1] == (byte)'C' && data[metadataEnd + 2] == (byte)'O') ||
                     (data[metadataEnd + 1] == (byte)'U' && data[metadataEnd + 2] == (byte)'P')))
                {
                    metadataEnd += 3;
                    continue;
                }
                break;
            }
            metadataEnd++;
        }

        var metadataText = Encoding.ASCII.GetString(data, metadataStart, metadataEnd - metadataStart);
        var lines = metadataText.Split('\n', StringSplitOptions.RemoveEmptyEntries);

        foreach (var line in lines)
        {
            var trimmed = line.Trim();
            var eqIndex = trimmed.IndexOf('=');
            if (eqIndex <= 0) continue;

            var key = trimmed[..eqIndex].Trim();
            var value = trimmed[(eqIndex + 1)..].Trim();

            efd.Metadata[key] = value;

            // Map to specific properties
            switch (key.ToUpperInvariant())
            {
                case "MY":
                    if (int.TryParse(value, out var year))
                        efd.ModelYear = year;
                    break;
                case "DRIVETRAIN":
                    efd.DriveTrain = value;
                    break;
                case "ENG":
                    efd.Engine = value;
                    break;
                case "FUEL":
                    efd.FuelType = value;
                    break;
                case "TRANS":
                    efd.Transmission = value;
                    break;
                case "BODY":
                    efd.BodyStyle = value;
                    break;
                case "EMISSIONS":
                    efd.Emissions = value;
                    break;
                case "PROGRAM":
                    efd.Program = value;
                    break;
                case "LEVEL":
                    efd.Level = value;
                    break;
                case "VERSION":
                    efd.Version = value;
                    break;
            }
        }

        // Try to extract "Generated by" text
        var generatedByStart = FindPattern(data, "Generated by "u8.ToArray());
        if (generatedByStart >= 0)
        {
            var end = generatedByStart + 13;
            while (end < data.Length && data[end] >= 0x20 && data[end] < 0x7F)
                end++;
            efd.GeneratorName = Encoding.ASCII.GetString(data, generatedByStart + 13, end - generatedByStart - 13).TrimEnd('.');
        }
    }

    private static void ParseFooter(byte[] data, EfdFile efd)
    {
        // Look for footer markers in last 512 bytes
        var footerStart = Math.Max(0, data.Length - 512);

        // Look for FGN (File Generator Name)
        var fgnIndex = FindPattern(data, "FGN"u8.ToArray(), footerStart);
        if (fgnIndex >= 0)
        {
            var nameStart = fgnIndex + 16; // Skip FGN marker and length bytes
            if (nameStart < data.Length)
            {
                var end = nameStart;
                while (end < data.Length && data[end] >= 0x20 && data[end] < 0x7F)
                    end++;
                if (end > nameStart)
                    efd.GeneratorName = Encoding.ASCII.GetString(data, nameStart, end - nameStart);
            }
        }

        // Look for FGV (File Generator Version)
        var fgvIndex = FindPattern(data, "FGV"u8.ToArray(), footerStart);
        if (fgvIndex >= 0)
        {
            var verStart = fgvIndex + 16;
            if (verStart < data.Length)
            {
                var end = verStart;
                while (end < data.Length && data[end] >= 0x20 && data[end] < 0x7F)
                    end++;
                if (end > verStart)
                    efd.GeneratorVersion = Encoding.ASCII.GetString(data, verStart, end - verStart);
            }
        }
    }

    private static void ExtractDataBlocks(byte[] data, EfdFile efd)
    {
        // The calibration data typically starts after metadata section
        // and ends before the footer section
        // For now, we'll treat the entire data section as one block

        // Find approximate data start (after metadata)
        var dataStart = 0x270; // Typical start after metadata

        // Find approximate data end (before footer markers)
        var dataEnd = data.Length - 256;

        // Look for actual data boundaries
        var upMarker = FindPattern(data, "UP"u8.ToArray(), 0x180);
        if (upMarker > 0 && upMarker < 0x300)
            dataStart = upMarker + 16;

        var footerStart = FindPattern(data, "AL"u8.ToArray(), data.Length - 512);
        if (footerStart > dataStart)
            dataEnd = footerStart;

        if (dataEnd > dataStart)
        {
            var blockData = new byte[dataEnd - dataStart];
            Array.Copy(data, dataStart, blockData, 0, blockData.Length);

            efd.DataBlocks.Add(new EfdDataBlock
            {
                Name = "Main Calibration",
                StartAddress = 0x00000000,
                Data = blockData,
                Checksum = CalculateChecksum(blockData)
            });
        }
    }

    private static int FindPattern(byte[] data, byte[] pattern, int startIndex = 0)
    {
        for (int i = startIndex; i <= data.Length - pattern.Length; i++)
        {
            var found = true;
            for (int j = 0; j < pattern.Length; j++)
            {
                if (data[i + j] != pattern[j])
                {
                    found = false;
                    break;
                }
            }
            if (found)
                return i;
        }
        return -1;
    }

    private static uint CalculateChecksum(byte[] data)
    {
        uint checksum = 0;
        foreach (var b in data)
            checksum += b;
        return checksum;
    }

    /// <summary>
    /// Validates that a file is a valid EFD file
    /// </summary>
    public static bool IsValidEfdFile(string filePath)
    {
        try
        {
            if (!File.Exists(filePath))
                return false;

            using var fs = File.OpenRead(filePath);
            var header = new byte[4];
            if (fs.Read(header, 0, 4) != 4)
                return false;

            return header.SequenceEqual(EfdMagic);
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Creates a new EFD file from calibration data
    /// </summary>
    public static byte[] Create(EfdFile efd)
    {
        using var ms = new MemoryStream();
        using var writer = new BinaryWriter(ms);

        // Write magic bytes
        writer.Write(EfdMagic);

        // Write header structure (simplified)
        WriteEbmlElement(writer, 0x4286, []); // Container start
        WriteEbmlElement(writer, 0x42F7, []); // Version
        WriteEbmlElement(writer, 0x42F2, []); // Read version
        WriteEbmlElement(writer, 0x42F3, []); // Max ID length
        WriteEbmlElement(writer, 0x4282, Encoding.ASCII.GetBytes("efd")); // Doc type

        // Write file segment marker
        WriteEbmlElement(writer, 0x4287, []);
        WriteEbmlElement(writer, 0x4285, []);
        writer.Write((byte)0x20);
        writer.Write(Encoding.ASCII.GetBytes("FS"));

        // Padding to align metadata
        while (ms.Position < 0x180)
            writer.Write((byte)0x00);

        // Write segment header
        writer.Write((byte)'S');
        writer.Write(new byte[8]);

        // Write metadata
        var metadata = new StringBuilder();
        metadata.AppendLine($"MY = {efd.ModelYear}");
        if (!string.IsNullOrEmpty(efd.DriveTrain))
            metadata.AppendLine($"DriveTrain = {efd.DriveTrain}");
        if (!string.IsNullOrEmpty(efd.Engine))
            metadata.AppendLine($"Eng = {efd.Engine}");
        if (!string.IsNullOrEmpty(efd.FuelType))
            metadata.AppendLine($"Fuel = {efd.FuelType}");
        if (!string.IsNullOrEmpty(efd.Transmission))
            metadata.AppendLine($"Trans = {efd.Transmission}");
        if (!string.IsNullOrEmpty(efd.BodyStyle))
            metadata.AppendLine($"Body = {efd.BodyStyle}");
        if (!string.IsNullOrEmpty(efd.Emissions))
            metadata.AppendLine($"Emissions = {efd.Emissions}");
        if (!string.IsNullOrEmpty(efd.Program))
            metadata.AppendLine($"Program = {efd.Program}");
        if (!string.IsNullOrEmpty(efd.Level))
            metadata.AppendLine($"Level = {efd.Level}");
        if (!string.IsNullOrEmpty(efd.Version))
            metadata.Append($"Version = {efd.Version}");

        var metadataBytes = Encoding.ASCII.GetBytes(metadata.ToString().Replace("\r\n", "\n"));
        writer.Write(metadataBytes);

        // Write country/comment markers
        writer.Write(new byte[] { 0x20, 0x43, 0x4F }); // " CO"
        writer.Write(new byte[8]);
        writer.Write(Encoding.ASCII.GetBytes("Generated by StellaFlash."));
        writer.Write(new byte[] { 0x20, 0x55, 0x50 }); // " UP"
        writer.Write(new byte[5]);

        // Write calibration data blocks
        foreach (var block in efd.DataBlocks)
        {
            writer.Write(block.Data);
        }

        // Write footer
        writer.Write(new byte[] { 0x20, 0x41, 0x4C }); // " AL"
        writer.Write(new byte[8]);
        writer.Write(new byte[] { 0x20, 0x4C, 0x45 }); // " LE"
        writer.Write(new byte[8]);

        // FGN - Generator name
        WriteEbmlElement(writer, 0x1046474E, Encoding.ASCII.GetBytes("StellaFlash"));

        // FGV - Generator version
        WriteEbmlElement(writer, 0x10464756, Encoding.ASCII.GetBytes("1.0.0"));

        // CAD - Creation date
        WriteEbmlElement(writer, 0x10434144, Encoding.ASCII.GetBytes($"File creation"));

        return ms.ToArray();
    }

    private static void WriteEbmlElement(BinaryWriter writer, int id, byte[] data)
    {
        // Write element ID
        if (id > 0xFFFFFF)
            writer.Write((byte)(id >> 24));
        if (id > 0xFFFF)
            writer.Write((byte)(id >> 16));
        if (id > 0xFF)
            writer.Write((byte)(id >> 8));
        writer.Write((byte)id);

        // Write size
        writer.Write((byte)0x01);
        writer.Write(new byte[6]);
        writer.Write((byte)data.Length);

        // Write data
        writer.Write(data);
    }

    /// <summary>
    /// Saves an EFD file to disk
    /// </summary>
    public static void Save(EfdFile efd, string filePath)
    {
        var data = Create(efd);
        File.WriteAllBytes(filePath, data);
        efd.FilePath = filePath;
        efd.FileSize = data.Length;
    }
}
